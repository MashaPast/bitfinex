{"name": "test_subscribe_to_action[AMPUST]", "status": "broken", "statusDetails": {"message": "websockets.exceptions.InvalidStatusCode: server rejected WebSocket connection: HTTP 429", "trace": "args = (), kwargs = {'event_loop': <_UnixSelectorEventLoop running=False closed=False debug=False>}, request = <SubRequest 'connection_fixture' for <Function test_subscribe_to_action[AMPUST]>>\nsetup = <function pytest_fixture_setup.<locals>.wrapper.<locals>.setup at 0x7f73389c4730>, finalizer = <function pytest_fixture_setup.<locals>.wrapper.<locals>.finalizer at 0x7f73389c47b8>\n\n    def wrapper(*args, **kwargs):\n        loop = kwargs['event_loop']\n        request = kwargs['request']\n        if strip_event_loop:\n            del kwargs['event_loop']\n        if strip_request:\n            del kwargs['request']\n    \n        gen_obj = f(*args, **kwargs)\n    \n        async def setup():\n            res = await gen_obj.__anext__()\n            return res\n    \n        def finalizer():\n            \"\"\"Yield again, to finalize.\"\"\"\n            async def async_finalizer():\n                try:\n                    await gen_obj.__anext__()\n                except StopAsyncIteration:\n                    pass\n                else:\n                    msg = \"Async generator fixture didn't stop.\"\n                    msg += \"Yield only once.\"\n                    raise ValueError(msg)\n    \n            loop.run_until_complete(async_finalizer())\n    \n        request.addfinalizer(finalizer)\n    \n>       return loop.run_until_complete(setup())\n\n../../.local/lib/python3.6/site-packages/pytest_asyncio/plugin.py:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/lib/python3.6/asyncio/base_events.py:484: in run_until_complete\n    return future.result()\n../../.local/lib/python3.6/site-packages/pytest_asyncio/plugin.py:78: in setup\n    res = await gen_obj.__anext__()\nwebsocket_API/conftest.py:11: in connection_fixture\n    ws_connection = await websockets.connect(URI)\n../../.local/lib/python3.6/site-packages/websockets/client.py:547: in __await_impl__\n    extra_headers=protocol.extra_headers,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <websockets.client.WebSocketClientProtocol object at 0x7f7338b19630>, wsuri = WebSocketURI(secure=True, host='api-pub.bitfinex.com', port=443, resource_name='/ws/2', user_info=None), origin = None\navailable_extensions = [<websockets.extensions.permessage_deflate.ClientPerMessageDeflateFactory object at 0x7f7338b19470>], available_subprotocols = None, extra_headers = None\n\n    async def handshake(\n        self,\n        wsuri: WebSocketURI,\n        origin: Optional[Origin] = None,\n        available_extensions: Optional[Sequence[ClientExtensionFactory]] = None,\n        available_subprotocols: Optional[Sequence[Subprotocol]] = None,\n        extra_headers: Optional[HeadersLike] = None,\n    ) -> None:\n        \"\"\"\n        Perform the client side of the opening handshake.\n    \n        :param origin: sets the Origin HTTP header\n        :param available_extensions: list of supported extensions in the order\n            in which they should be used\n        :param available_subprotocols: list of supported subprotocols in order\n            of decreasing preference\n        :param extra_headers: sets additional HTTP request headers; it must be\n            a :class:`~websockets.http.Headers` instance, a\n            :class:`~collections.abc.Mapping`, or an iterable of ``(name,\n            value)`` pairs\n        :raises ~websockets.exceptions.InvalidHandshake: if the handshake\n            fails\n    \n        \"\"\"\n        request_headers = Headers()\n    \n        if wsuri.port == (443 if wsuri.secure else 80):  # pragma: no cover\n            request_headers[\"Host\"] = wsuri.host\n        else:\n            request_headers[\"Host\"] = f\"{wsuri.host}:{wsuri.port}\"\n    \n        if wsuri.user_info:\n            request_headers[\"Authorization\"] = build_authorization_basic(\n                *wsuri.user_info\n            )\n    \n        if origin is not None:\n            request_headers[\"Origin\"] = origin\n    \n        key = build_request(request_headers)\n    \n        if available_extensions is not None:\n            extensions_header = build_extension(\n                [\n                    (extension_factory.name, extension_factory.get_request_params())\n                    for extension_factory in available_extensions\n                ]\n            )\n            request_headers[\"Sec-WebSocket-Extensions\"] = extensions_header\n    \n        if available_subprotocols is not None:\n            protocol_header = build_subprotocol(available_subprotocols)\n            request_headers[\"Sec-WebSocket-Protocol\"] = protocol_header\n    \n        if extra_headers is not None:\n            if isinstance(extra_headers, Headers):\n                extra_headers = extra_headers.raw_items()\n            elif isinstance(extra_headers, collections.abc.Mapping):\n                extra_headers = extra_headers.items()\n            for name, value in extra_headers:\n                request_headers[name] = value\n    \n        request_headers.setdefault(\"User-Agent\", USER_AGENT)\n    \n        self.write_http_request(wsuri.resource_name, request_headers)\n    \n        status_code, response_headers = await self.read_http_response()\n        if status_code in (301, 302, 303, 307, 308):\n            if \"Location\" not in response_headers:\n                raise InvalidHeader(\"Location\")\n            raise RedirectHandshake(response_headers[\"Location\"])\n        elif status_code != 101:\n>           raise InvalidStatusCode(status_code)\nE           websockets.exceptions.InvalidStatusCode: server rejected WebSocket connection: HTTP 429\n\n../../.local/lib/python3.6/site-packages/websockets/client.py:296: InvalidStatusCode"}, "attachments": [{"name": "log", "source": "728c121b-e026-441b-b1a8-24e6e4e18506-attachment.txt", "type": "text/plain"}, {"name": "stderr", "source": "17ba430b-bb72-40eb-8eab-13bb75e28675-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "symbol", "value": "'AMPUST'"}], "start": 1582626367216, "stop": 1582626367216, "uuid": "4b016ba4-033a-4d1e-928f-290a6b8d3f6c", "historyId": "7c6e83d53d09410b6e6c390536779af9", "fullName": "websocket_API.trades.test_trades_ws#test_subscribe_to_action[AMPUST]", "labels": [{"name": "tag", "value": "asyncio"}, {"name": "parentSuite", "value": "websocket_API.trades"}, {"name": "suite", "value": "test_trades_ws"}, {"name": "subSuite"}, {"name": "host", "value": "local"}, {"name": "thread", "value": "12305-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "websocket_API.trades.test_trades_ws"}]}